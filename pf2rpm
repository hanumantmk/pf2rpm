#!/usr/bin/perl -w

use strict;

use Getopt::Long;
use List::Util qw( max first );
use Archive::Tar;
use LWP;
use URI;
use JSON;
use File::Basename;
use File::Path qw( make_path );
use Template;
use version;

use constant SEARCH_URI => "/modules.json";
use constant DEP_INFO_URI => "/api/v1/releases.json";

use constant APPLICATIONS => {
    'search' => \&search,
    'create' => \&create,
};

my $verbose;
my $debug;

my $repo;
my $forge = "http://forge.puppetlabs.com";

GetOptions(
    'forge=s' => \$forge,
    'repo=s'  => \$repo,
    'verbose' => \$verbose,
    'debug'   => \$debug,
    'help'    => sub { &HELP(0) },
) or HELP(1);

my $application = shift @ARGV;

$application ||= '';

if (APPLICATIONS->{$application}) {
    APPLICATIONS->{$application}->(@ARGV);
} else {
    print "invalid application '$application'\n";
    HELP(1);
}

sub search {
    my ($term) = @_;
    my $ua = make_ua();

    verbose("Searching for $term...");

    my @data = map {
        [$_->{full_name}, $_->{desc}]
    } @{from_json(make_req($ua, $forge . SEARCH_URI, ["q", $term]))};

    render_table(\@data);
}

sub create {
    my ($package, $version) = @_;

    $repo or print "Please enter a repo\n" and HELP(1);

    verbose("Ensuring paths for $repo");

    make_path(
	$repo,
	"$repo/SOURCES",
	"$repo/SPECS",
    );

    my $ua = make_ua();

    my $output = get_dependency_info($ua, $package, $version);

    foreach my $pkg (keys %$output) {
	my $info = $output->{$pkg};

	ensure_tarball($ua, $info);
	write_specfile($info);
    }
}

sub ensure_tarball {
    my ($ua, $info) = @_;

    verbose("Ensuring tarball for $info->{file}");

    my $fname = "$repo/SOURCES/$info->{file}";

    if (! -e $fname) {
        verbose("Fetching tarball for $info->{file}");

	my $data = make_req($ua, "$forge/$info->{url}");

	open FILE, '>', $fname or die "Couldn't open file $fname: $!";

	print FILE $data;

	close FILE or die "Couldn't close file $fname: $!";
    }
}

sub get_dependency_info {
    my ($ua, $package, $version) = @_;

    verbose("Gathering dependency info for $package...");

    my $deps = from_json(
        make_req($ua, $forge . DEP_INFO_URI, [
            'module', "$package",
            ( $version ? ("version", $version) : ()),
        ])
    );

    my %output = map {
        my $pkg = $_;

        my ($latest) = map { $_->[1] } sort {
            $b->[0] <=> $a->[0]
        } map {
            [ parse_version($_->{version}), $_ ];
        } @{$deps->{$pkg}};

        my ($version, $release) = split /-/, $latest->{version};

        $pkg, {
            version      => $version,
            release      => $release,
            url          => "$pkg/$latest->{version}.tar.gz",
            file         => "puppetforge-" . basename($latest->{file}),
            dependencies => $latest->{dependencies},
        };
    } keys %$deps;

    return \%output;
}

sub parse_version {
    my $vstr = shift;

    $vstr =~ s/[a-zA-Z]//g;
    $vstr =~ s/-/./g;

    version->parse($vstr);
}

sub make_ua {
    my $ua = LWP::UserAgent->new;
    $ua->agent("pf2rpm/0.1 ");

    return $ua;
}

sub make_req {
    my ($ua, $uri, $values) = @_;

    my $url = URI->new($uri);
    $url->query_form(@$values);

    verbose("Requesting $url...");

    my $response = $ua->get($url);

    if ($response->is_success) {
        verbose("Succesfully retrieved content for $url");
        debug("Content = [" . $response->content . "]");

        return $response->content;
    } else {
        die "Request failed for $url: " . $response->status_line;
    }
}

sub render_table {
    my ($data) = @_;

    my @max_widths;

    foreach my $row (@$data) {
        for (my $i = 0; $i < @$row; $i++) {
            $max_widths[$i] ||= 0;
            $max_widths[$i] = max($max_widths[$i], length($row->[$i]));
        }
    }

    my $fmt = join(' ', map {
        "%-${_}s"
    } @max_widths) . "\n";

    printf($fmt, @$_) for @$data;
}

sub write_specfile {
    my $info = shift;

    my $tar = Archive::Tar->new("$repo/SOURCES/$info->{file}");

    $tar or die "Couldn't open $info->{file}";

    my $metadata_file = first { 
	$_->name =~ /metadata\.json$/
    } $tar->get_files;

    if (! $metadata_file) {
	die "no metadata.json for $info->{file}";
    }

    my $m = from_json($metadata_file->get_content);

    my @deps = map {
	my $pkg = $_->{name};
	$pkg =~ s/\//-/g;

	"puppetforge-$pkg $_->{version_requirement}";
    } @{$m->{dependencies}};

    my $module = $m->{name};
    $module =~ s/^$m->{author}-//;

    my $builddir = join("-",
        $m->{name},
        $info->{version},
        ($info->{release} ? $info->{release} : ()),
    );

    my $vars = {
	dependencies => \@deps,
	description  => $m->{description},
	files        => ["metadata.json", keys %{$m->{checksums}}],
	license      => $m->{license},
	module       => $module,
	name         => "puppetforge-$m->{name}",
	summary      => $m->{summary},
	version      => $info->{version},
        release      => $info->{release} || 1,
        source       => $info->{file},
        builddir     => $builddir,
    };

    my $tt = Template->new();

    my $template = SPEC_TEMPLATE();

    my $spec_name = "$repo/SPECS/puppetforge-$m->{name}.spec";

    verbose("Writing $spec_name");

    $tt->process(\$template, $vars, $spec_name);
}

sub verbose { print "@_\n" if $verbose || $debug }
sub debug { print "@_\n" if $debug }

sub HELP {
    my $exit = shift;

    print <<HELP ;
$0 - APPLICATION [OPTIONS]

Applications
    search      search for a package
    create      create rpms

Options
    --repo      the repository to work in
    --forge     url serving the puppet forge api
    --help      this help notice

Debugging
    --verbose   High level messages
    --debug     Low level messages
HELP

    exit $exit;
}

use constant SPEC_TEMPLATE => <<'SPEC' ;
%define name [% name %]
%define release   [% release %]
%define version   [% version %]

Summary: [% summary %]
License: [% license %]
Name:%{name}
Version:%{version}
Release:%{release}
Source: [% source %]

[% FOREACH dep IN dependencies.sort %]
Requires: [% dep %] [% END %]

%prep
%setup -q -n [% builddir %]

%install
mkdir -p %{buildroot}%{_datarootdir}/puppet/modules/[% module %]
cp -r * %{buildroot}%{_datarootdir}/puppet/modules/[% module %]

%files
[% FOREACH file IN files.sort %]
%{_datarootdir}/puppet/modules/[% module %]/[% file %][% END %]

%description
[% description %]

SPEC
